#chinese spring x paragon f7 sacha data preparation
#written by Alex Coulton - alex.coulton@bristol.ac.uk

source("scripts/r/functions.R")
library(dplyr)
library(tibble)


#     ____________________________________________________________________________
#     INITIAL PROCESSING                                                                                                            ####

convert.aas.to.rqtl = function(aasoutputfile, parents){
    #aasoutputfile - .txt file generated by axiom analysis suite
    #parents (optional) - character vector of parental variety names
    if(missing(parents)) parents = c("Paragon", "Apogee")
    
    #convert output of axiom analysis suite to a data.frame suitable for analysis with rQTL
    nd = read.table(aasoutputfile)
    nd=t(nd)
    nd[nd=="AA"] = "A"
    nd[nd=="BB"] = "B" 
    nd[nd=="AB"] = "H"
    nd[nd=="NoCall"] = "-"
    colnames(nd)=nd[1,]
    nd[1,]=1
    nd=cbind(nd[,1], nd)
    nd[,1]=seq(0,nrow(nd)-1,1)
    nd[1,1]=""
    nd[1,2]=""
    #bring parents to top of dataframe
    if(length(grep(parents[[1]], nd[,2])) == 0){
     nd2 = nd 
    } else {
    nd2=rbind(nd[grep(parents[[1]],nd[,2]),], nd[-c(grep(parents[[1]],nd[,2])),])
    }
    
    if(length(grep(parents[[2]], nd[,2])) == 0){
        nd3 = nd2 
    } else {
        nd3=rbind2(nd2[grep(parents[[2]],nd2[,2]),], nd2[-c(grep(parents[[2]],nd2[,2])),])
    }
    
    rqtl.chromo.row.coord = which(nd3[, 3] == 1)
    
    nd3=rbind(nd3[rqtl.chromo.row.coord,],nd3[-rqtl.chromo.row.coord,])
    
    nd3[,1]=seq(0,nrow(nd)-1,1)
    nd3[1,1]=""
    nd3[1,2]=""
    
    rownames(nd3)=seq(1,nrow(nd3),1)
    return(nd3)
}

cs.x.p.geno.data = convert.aas.to.rqtl("original_data/axiom analysis suite output/CSxP.F7.Allen.PolyHighRes.txt", c("Paragon", "Chinese_Spring"))

replace.aas.genotype.format.w.rqtl.format = function(dataframe){
    dataframe[dataframe == "AA"] = "A"
    dataframe[dataframe == "BB"] = "B"
    dataframe[dataframe == "AB"] = "H"
    dataframe[dataframe == "BA"] = "H"
    dataframe[dataframe == "NoCall"] = "-"
    return(dataframe)
}

cs.x.p.geno.data = replace.aas.genotype.format.w.rqtl.format(cs.x.p.geno.data)

grab.columns.in.which.parents.are.concordant = function(dataframe, parent){
    #when multiple parent individuals of the same variety are present in the dataset, this grabs the column coordinates in which those parents are the same
    #supply dataframe in rqtl format and name of parent variety (only processes one parent at a time)
    parent.row.coords = grep(parent, dataframe[, 2])
    parent.df = dataframe[parent.row.coords, ]
    parent.df = as.data.frame(parent.df)
    parent.df[] = lapply(parent.df, as.character)
    
    g = lapply(parent.df, function(x){
        b = x[[1]] == x[[2]]
        c = x[[2]] == x[[3]]
        g = all(c(c, b))
        return(g)
    })
    
    which(unlist(g))
    
}

cs.x.p.geno.data2 = cs.x.p.geno.data[, c(1, 2, as.numeric(grab.columns.in.which.parents.are.concordant(cs.x.p.geno.data, "Paragon")))]

convert.cerealsdb.format.to.rqtl = function(df){
    g = df[, 1:3]
    g = t(g)
    colnames(g) = g[2, ]
    
    g = as.data.frame(g)
    g = add_column(g, probeset_id = g[1, 1], .before = colnames(g)[1])
    g = add_column(g, V1 = 1, .before = colnames(g)[1])
    g = g[3, ]
    g = convert.to.character.data.frame(g)
    g = replace.aas.genotype.format.w.rqtl.format(g)
    return(g)
}

convert.to.character.data.frame = function(df){
    df = as.data.frame(df)
    g = df
    g[] = lapply(df, as.character)
    return(g)
}



colnames(cs.x.p.geno.data2)[1] = "V1"


cs.x.p.geno.data2 = convert.to.character.data.frame(cs.x.p.geno.data2)




#     ____________________________________________________________________________
#     DEFINE FUNCTIONS                                                                                                                ####


#remove columns in which parents are the same

rm.interparental.homozygosities = function(df, parent.rows){
    #df - the dataframe in rqtl format for which to remove columns in which parents are heterozygous
    #parent.rows - a numeric vector of length 2 providing the row coordinates of each parent in the cross.
    
    if(length((which(df[parent.rows[[1]], 3:ncol(df)] == df[parent.rows[[2]], 3:ncol(df)]) + 2)) != 0) {
        df = df[, -(which(df[parent.rows[[1]], 3:ncol(df)] == df[parent.rows[[2]], 3:ncol(df)]) + 2)]    
    }
    return(df)
}

#remove parental heterozygosities
rm.parental.het = function(df, parent.rows){
    #df - the dataframe in rqtl format for which to remove columns in which parents are heterozygous
    #parent.rows - a numeric vector of length 2 providing the row coordinates of each parent in the cross.
    if(length(which(df[parent.rows[1], ] == "H")) != 0) g = df[, -which(df[parent.rows[1], ] == "H")]
    if(length(which(g[parent.rows[2], ] == "H")) != 0) g = g[, -which(g[parent.rows[2], ] == "H")]
    return(g)
}


#remove parental nocalls
rm.parental.nocall = function(df, parent.rows){
    #df - the dataframe in rqtl format for which to remove columns in which parents are heterozygous
    #parent.rows - a numeric vector of length 2 providing the row coordinates of each parent in the cross.
    if(length(which(df[parent.rows[1], ] == "-")) != 0) g = df[, -which(df[parent.rows[1], ] == "-")]
    if(length(which(g[parent.rows[2], ] == "-")) != 0) g = g[, -which(g[parent.rows[2], ] == "-")]
    return(g)
}

cleanup = function(df, parent.rows){
    df = rm.interparental.homozygosities(df, parent.rows)
    df = rm.parental.het(df, parent.rows)
    df = rm.parental.nocall(df, parent.rows)
    return(df)
}

assign.parental.genotypes = function(df, parent.rows){
    #performs "flipping algorithm" to assign parental genotypes to data. 
    #df - the dataframe in rqtl format for which to remove columns in which parents are heterozygous
    #parent.rows - a numeric vector of length 2 providing the row coordinates of each parent in the cross.
    
    #make new df w/ only parents (2 rows total)
    pc2 = df[c(parent.rows[[1]], parent.rows[[2]]), ]
    pc2 = as.data.frame(pc2)
    pc2 = convert.to.character.data.frame(pc2)
    
    df = as.data.frame(df)
    
    #make list of columns to flip
    n = which(lapply(pc2, function(x){
        if(x[1] == "A" & x[2] == "B"){
            return(T)
        } else return(F)
    }) == T)
    
    #flip columns in main dataframe
    df[, n] = lapply(df[, n], function(x){
        g = x
        
        g[g == "A"] = "X"
        g[g == "B"] = "A"
        g[g == "X"] = "B"
        
        return(g)
    })

    
    return(df)
}

remove.excess.parents = function(df, parent.name){
    #removes all but one of the parent individuals for one of the parents in the cross (only operates on one parent at a time)
    #df - df in rqtl format
    #parent.name - character string of the parent to perform operation on
    to.remove = grep(parent.name, df$probeset_id)
    df = df[-to.remove[2:length(to.remove)], ]
    return(df)
}


#     ____________________________________________________________________________
#     PROCESS DATA                                                                                                                        ####


combined.geno.data3 = cleanup(combined.geno.data, 2:3)

combined.geno.data4 = assign.parental.genotypes(combined.geno.data3, 2:3)

combined.geno.data4 = remove.excess.parents(combined.geno.data4, "Paragon")

write.csv(combined.geno.data4, "processed_data/genotypes/chinese.spring.x.paragon/cs.x.para.flipped.csv", row.names = F)



